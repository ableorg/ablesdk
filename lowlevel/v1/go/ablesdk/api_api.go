/*
 * Able API
 *
 * SDK for building integrations with Able.
 *
 * API version: 1.20230623221606
 * Contact: support@able.ai
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ablesdk

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// APIApiService APIApi service
type APIApiService service

type ApiAPIAcquireDocumentContentV1Request struct {
	ctx _context.Context
	ApiService *APIApiService
	extensionId string
	workerName string
	body *V1AcquireDocumentContentRequestV1Body
}

func (r ApiAPIAcquireDocumentContentV1Request) Body(body V1AcquireDocumentContentRequestV1Body) ApiAPIAcquireDocumentContentV1Request {
	r.body = &body
	return r
}

func (r ApiAPIAcquireDocumentContentV1Request) Execute() (V1AcquiredDocumentContentV1, *_nethttp.Response, error) {
	return r.ApiService.APIAcquireDocumentContentV1Execute(r)
}

/*
 * APIAcquireDocumentContentV1 Acquires a DocumentContent task. The task represents a document to be processed and once acquired, should be processed within the expected execution time. If the task is not completed within the expected time, it will be made available for acquisition by other workers.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionId The unique ID of the extension.
 * @param workerName The name of the worker that will process the task.
 * @return ApiAPIAcquireDocumentContentV1Request
 */
func (a *APIApiService) APIAcquireDocumentContentV1(ctx _context.Context, extensionId string, workerName string) ApiAPIAcquireDocumentContentV1Request {
	return ApiAPIAcquireDocumentContentV1Request{
		ApiService: a,
		ctx: ctx,
		extensionId: extensionId,
		workerName: workerName,
	}
}

/*
 * Execute executes the request
 * @return V1AcquiredDocumentContentV1
 */
func (a *APIApiService) APIAcquireDocumentContentV1Execute(r ApiAPIAcquireDocumentContentV1Request) (V1AcquiredDocumentContentV1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AcquiredDocumentContentV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIApiService.APIAcquireDocumentContentV1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extensions/{extensionId}/documentContentQueue/{workerName}/acquire"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workerName"+"}", _neturl.PathEscape(parameterToString(r.workerName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPICompleteDocumentContentV1Request struct {
	ctx _context.Context
	ApiService *APIApiService
	extensionId string
	workerName string
	documentContentId string
	body *V1CompleteDocumentContentRequestV1Body
}

func (r ApiAPICompleteDocumentContentV1Request) Body(body V1CompleteDocumentContentRequestV1Body) ApiAPICompleteDocumentContentV1Request {
	r.body = &body
	return r
}

func (r ApiAPICompleteDocumentContentV1Request) Execute() (V1CompletedDocumentContentV1, *_nethttp.Response, error) {
	return r.ApiService.APICompleteDocumentContentV1Execute(r)
}

/*
 * APICompleteDocumentContentV1 Completes a DocumentContent task. The task should be marked as complete after successful processing or if an error occurs during processing. If completed successfully, any extracted document attributes should be included in the completion request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionId The unique ID of the extension.
 * @param workerName The name of the worker that processed the task.
 * @param documentContentId The ID of the document content that was processed.
 * @return ApiAPICompleteDocumentContentV1Request
 */
func (a *APIApiService) APICompleteDocumentContentV1(ctx _context.Context, extensionId string, workerName string, documentContentId string) ApiAPICompleteDocumentContentV1Request {
	return ApiAPICompleteDocumentContentV1Request{
		ApiService: a,
		ctx: ctx,
		extensionId: extensionId,
		workerName: workerName,
		documentContentId: documentContentId,
	}
}

/*
 * Execute executes the request
 * @return V1CompletedDocumentContentV1
 */
func (a *APIApiService) APICompleteDocumentContentV1Execute(r ApiAPICompleteDocumentContentV1Request) (V1CompletedDocumentContentV1, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1CompletedDocumentContentV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIApiService.APICompleteDocumentContentV1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extensions/{extensionId}/documentContentQueue/{workerName}/complete/{documentContentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workerName"+"}", _neturl.PathEscape(parameterToString(r.workerName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentContentId"+"}", _neturl.PathEscape(parameterToString(r.documentContentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPICreateDocumentContentV1Request struct {
	ctx _context.Context
	ApiService *APIApiService
	extensionId string
	body *InlineObject
}

func (r ApiAPICreateDocumentContentV1Request) Body(body InlineObject) ApiAPICreateDocumentContentV1Request {
	r.body = &body
	return r
}

func (r ApiAPICreateDocumentContentV1Request) Execute() (V1DocumentContent, *_nethttp.Response, error) {
	return r.ApiService.APICreateDocumentContentV1Execute(r)
}

/*
 * APICreateDocumentContentV1 Creates a new DocumentContent. The DocumentContent represents a document from an external system that needs to be processed.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionId The unique ID of the extension.
 * @return ApiAPICreateDocumentContentV1Request
 */
func (a *APIApiService) APICreateDocumentContentV1(ctx _context.Context, extensionId string) ApiAPICreateDocumentContentV1Request {
	return ApiAPICreateDocumentContentV1Request{
		ApiService: a,
		ctx: ctx,
		extensionId: extensionId,
	}
}

/*
 * Execute executes the request
 * @return V1DocumentContent
 */
func (a *APIApiService) APICreateDocumentContentV1Execute(r ApiAPICreateDocumentContentV1Request) (V1DocumentContent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DocumentContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIApiService.APICreateDocumentContentV1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extensions/{extensionId}/documentContent"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
